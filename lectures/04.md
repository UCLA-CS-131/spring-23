---
title: Lecture 04
week: 2
lecture_date: 2023-04-10
author: Matt Wang
original_author: Boyan Ding
originally_written: 2022-10-03
layout: lecture
parent: Lecture Notes
published: false
---

## First-class and higher-order functions

One key characteristic of functional languages is that they enable you to treat a function just like any other variable. In other words, functions are *first-class*!

Formally speaking, a language with **first-class functions** treats functions like any other data. They can be:

- stored in variables or data structures
- passed as arguments to other functions
- returned as values by functions

As we'll see, these features enable us to write cleaner, more *composable* functions.

One consequence of first-class functions is something called a **higher-order function**, which is either:

- a function that accepts another function as an argument, and/or
- a function that returns another function as its return value

The following example exercises the property of passing functions as arguments:

```hs
-- first.hs
insult :: String -> String
insult name = name ++ " is so cringe!"

praise :: String -> String
praise name = name ++ " is dank!"

talk_to :: String -> (String -> String) -> String
talk_to name talk_func
  | name == "Carey" = "No comment."
  | otherwise = (talk_func name)
```

`talk_to` is a higher-order function: its second argument, `talk_func`, is itself a function that takes in a `String` and returns a `String`. That's reflected in its type: `(String -> String)`.

Let's give it a shot:

```console
ghci> :load first
[1 of 1] Compiling Main             ( first.hs, interpreted )
ghci> talk_to "Devan" praise
"Devan is dank!"
ghci> talk_to "Brendan" insult
"Brendan is so cringe!"
ghci> talk_to "Carey" insult
"No comment."
```

This second example *returns* a function!

```hs
-- first.hs
get_pickup_func :: Int -> (String -> String)
get_pickup_func born
  | born >= 1997 && born <= 2012 = pickup_genz
  | otherwise = pickup_other
 where
   pickup_genz name = name ++ ", you've got steez!"
   pickup_other name = name ++ ", you've got style!"
```

The higher-order function `get_pickup_func` returns different functions according to the argument `born`. The returned function can be stored into variable and invoked later.

```console
ghci> :load first
[1 of 1] Compiling Main             ( first.hs, interpreted )
ghci> pickup_fn = get_pickup_func 2003
ghci> pickup_fn "Jayathi"
"Jayathi, you've got steez!"
ghci> get_pickup_func 1971 "Carey"
"Carey, you've got style!"
```

Although first-class and higher-order functions originate from functional programming, they are a pillar of virtually all modern programming languages.

Their use-cases include:

- providing comparison functions for sorting
- as callbacks when events trigger
- enabling multi-threading

Some examples:

```js
// JavaScript
const sortByDate = (a,b) => {
  if (a.date < b.date) return -1;
  if (a.date > b.date ) return 1;
  return 0;
}

movies.sort(sortByDate);
```

```js
// JavaScript
const handleClick = function (event) {
   alert("A button was clicked!");
};

// Select big button from HTML web page
var button = document.querySelector('#big-button');
// Specify what func should be called when it's clicked
button.addEventListener('click', handleClick);
```

```cpp
// C++
void foo()      { /* does some work & returns */ }
void bar(int x) { /* does some work & returns */ }

int main() {
  std::thread thread1(foo), thread2(bar,42);

  // Run main, foo and bar until they all finish
  thread1.join(); // pause until foo() finishes
  thread2.join(); // pause until bar() finishes
  std::cout << "main, foo and bar completed.\n";
}
```

## Map, Filter and Reduce

Here we introduce a key set of higher-order utility functions to process lists that are included in virtually all functional programming languages.

These functions fall into three categories: mappers, filters and reducers.

- A **mapper** function performs a one-to-one transformation from one list of values to another list of values using a _transform function_
- A **filter** function filters out items from one list of values using a _predicate function_ to produce another list of values
- A **reducer** function operates on a list of values and collapses them into a single output value

### Map

A mapper function maps a list of values to another list of values. Haskell provides a mapper function called `map` that accepts two parameters:

1. A function to apply to every element of a list
2. A list to operate on

The type signature of map is: `map :: (a -> b) -> [a] -> [b]`

- The first argument is a function that maps an individual item from a value of type `a` to a value of type `b` (`a` and `b` can be the same)
- The second argument is a list of type `a`
- The return value is a list of type `b`

We can define some functions to use with `map`:

```hs
-- mappy.hs
cube :: Double -> Double
cube x = x^3

one_over  :: Double -> Double
one_over x = 1/x

is_even :: Int -> Bool
is_even x = x `
```

```console
ghci> :load mappy
[1 of 1] Compiling Main             ( mappy.hs, interpreted )
ghci> map cube [2,4,10]
[8,64,1000]
ghci> map one_over [2,4,8]
[.5,.25,.125]
ghci> map is_even [1,2,3,4,6]
[False,True,False,True,True]
ghci> map reverse ["mouse","cat","fly"]
["esuom","tac","ylf"]
```

In the last invocation, we used Haskell's library function `reverse`.

So how does the map function actually work? It's simple. We can use pattern matching we have just learned to implement it.

```hs
-- map.hs
map :: (a -> b) -> [a] -> [b]
map func [] = []
map func (x:xs) =
  (func x) : map func xs
```

### Filter

A filter is a function that filters items from an input list to produce a new output list. Haskell provides a function called `filter` that accepts two parameters:

1. A function that determines if an item in the input list should be included in the output list
2. A list to operate on

The type signature of filter is: `filter :: (a -> Bool) -> [a] -> [a]`

- The first argument is a predicate function that determines if a value from the input list should be included in the output
- The second argument is a list of type `a`
- The returned list include all the items that passed the filter

The filter function can also be easily implemented as follows:

```hs
filter :: (a -> Bool) -> [a] -> [a]
filter predicate [] = []
filter predicate (x:xs)
 | (predicate x) = x : (filter predicate xs)
 | otherwise = filter predicate xs
```

That's it for this time. Next time we will continue with the last one of the three: reducer (`foldl`/`foldr` in Haskell)
